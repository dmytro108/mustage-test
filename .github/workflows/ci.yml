# ============================================
# CI Workflow: Build, scan, push PR image and run smoke tests on a Kind cluster via Ingress
# Triggers: pull_request on main
# Secrets used: DOCKER_USERNAME, DOCKER_PASSWORD, REDIS_PASSWORD
# Notes: Ingress readiness waits added; /redis must return '"status":true'
# ============================================
name: Continuous Integration

on:
  pull_request:
    branches:
    - main

permissions:
  contents: read
  actions: write

env:
  IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/mustage-test
  PR_TAG: pr-${{ github.event.number }}

jobs:
  # CI Job 1: Build, scan, and push PR-tagged image
  build_image:
    name: Build Image, Compliance and Push
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    # Enable Buildx for advanced Docker builds (cache/multi-platform)
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    # Build the image tagged with PR number for isolation (pr-*)
    - name: Build image
      run: |
        docker build -t "${{ env.IMAGE_NAME }}:${{ env.PR_TAG }}" .

    # Security gate: fail build on HIGH/CRITICAL vulns (ignores unfixed)
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.IMAGE_NAME }}:${{ env.PR_TAG }}
        format: 'table'
        exit-code: '1'
        ignore-unfixed: true
        vuln-type: 'os,library'
        severity: 'CRITICAL,HIGH'

    # Required to push the PR-tagged image
    - name: Log in to Docker Hub
      if: success()
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    # Publish PR image so the Kind cluster can pull it
    - name: Push image to registry
      if: success()
      run: |
        docker push ${{ env.IMAGE_NAME }}:${{ env.PR_TAG }}

  # CI Job 2: Provision Kind + Ingress and run smoke tests via /redis
  deploy_for_tests:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: build_image
    steps:
    # Spin up ephemeral Kubernetes cluster (Kind) for smoke tests
    - name: Create k8s Kind Cluster
      uses: helm/kind-action@v1.5.0

    # Install and explicitly wait for ingress-nginx readiness to avoid flakes
    - name: Install Ingress Controller
      run: |
        kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml

        # Wait for Ingress Controller to be fully ready (pod Ready condition)
        # Why: Ensures the nginx controller pod is created, containers started,
        # readiness probes passing, and the controller is serving traffic internally.
        # This does NOT by itself guarantee the admission webhook Service is reachable yet.

        echo "=== Waiting for Ingress Controller to be ready ==="
        kubectl wait --namespace ingress-nginx \
          --for=condition=ready pod \
          --selector=app.kubernetes.io/component=controller \
          --timeout=120s

        # Wait for admission webhook/controller Deployment availability        
        echo "=== Waiting for Ingress admission webhook ==="
        kubectl wait --namespace ingress-nginx \
          --for=condition=available deployment/ingress-nginx-controller \
          --timeout=120s

        # Extra stabilization buffer
        echo "=== Additional wait for webhook service stability ==="
        sleep 20

    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    # Apply manifests and wire image + secrets specific to this PR run
    - name: Deploy to k8s
      run: |
        # Fix image reference
        sed -i "s|image: YOUR_DOCKER_REGISTRY/mustage-test:0.1.0|image: ${{ env.IMAGE_NAME }}:${{ env.PR_TAG }}|g" k8s/app.yml

        # Fix Redis password with proper base64 encoding
        REDIS_PASSWORD_B64=$(echo -n "${{ secrets.REDIS_PASSWORD }}" | base64 -w 0)
        sed -i "s/REDIS_PASSWORD: \"\"/REDIS_PASSWORD: $REDIS_PASSWORD_B64/g" k8s/secret.yml

        # Apply resources in order, excluding Ingress first
        echo "=== Applying resources ==="
        kubectl apply -f k8s/secret.yml
        kubectl apply -f k8s/redis.yml
        kubectl apply -f k8s/app.yml

        # Add diagnostic logging
        echo "=== Deployment Status ==="
        kubectl get pods -o wide
        kubectl get services
        kubectl get ingress

        echo "=== Waiting for pods to be ready ==="
        kubectl wait --for=condition=ready pod -l app=redis --timeout=60s
        kubectl wait --for=condition=ready pod -l app=nestjs-app --timeout=120s

    # Smoke test via Ingress with retries and rich diagnostics on failure
    - name: Test API endpoint
      run: |
        echo "=== Checking Ingress status ==="
        kubectl describe ingress nestjs-app-ingress

        # Allow time for the Ingress to be admitted and NGINX to load the config
        # Note: On Kind there is no external LoadBalancer; .status.loadBalancer may remain empty.
        # We later fall back to the node IP or localhost. This delay also gives NGINX time to
        # reconcile the new Ingress resource and start routing traffic.
        echo "Waiting for Ingress to be ready..."
        sleep 30

        INGRESS_IP=$(kubectl get ingress nestjs-app-ingress -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        if [ -z "$INGRESS_IP" ]; then
          echo "Failed to get Ingress IP. Trying Node IP..."
          INGRESS_IP=$(kubectl get node -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
        fi

        if [ -z "$INGRESS_IP" ]; then
          echo "Failed to get any IP. Using localhost for Kind cluster..."
          INGRESS_IP="localhost"
        fi

        echo "Testing Ingress at IP: $INGRESS_IP"

        # Test with more attempts
        for i in {1..5}; do
          echo "=== Attempt $i ==="
          response=$(curl -sv "http://$INGRESS_IP/redis" 2>&1 || true)
          echo "Response: $response"
          
          if echo "$response" | grep -q '"status":true'; then
            echo "API test passed."
            exit 0
          fi
          
          if [ $i -lt 5 ]; then
            echo "Attempt $i failed. Checking pod status..."
            kubectl get pods -o wide
            echo "Retrying in 15 seconds..."
            sleep 15
          fi
        done

        echo "=== API test failed after 5 attempts. Collecting diagnostics ==="
        echo "=== Pod Status ==="
        kubectl get pods -o wide
        echo "=== NestJS App Logs ==="
        kubectl logs -l app=nestjs-app --tail=100
        echo "=== Redis Logs ==="
        kubectl logs -l app=redis --tail=50
        echo "=== Events ==="
        kubectl get events --sort-by=.metadata.creationTimestamp
        exit 1
